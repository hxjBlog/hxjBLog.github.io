<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于docker容器内逃逸</title>
    <link href="/2024/03/07/%E5%85%B3%E4%BA%8E%E5%AE%9E%E9%AA%8C%E5%AE%A4%E9%81%AD%E5%8F%97%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB%EF%BC%8C%E8%AE%A8%E8%AE%BAdocker%E5%AE%B9%E5%99%A8%E5%86%85%E9%80%83%E9%80%B8%E9%97%AE%E9%A2%98/"/>
    <url>/2024/03/07/%E5%85%B3%E4%BA%8E%E5%AE%9E%E9%AA%8C%E5%AE%A4%E9%81%AD%E5%8F%97%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB%EF%BC%8C%E8%AE%A8%E8%AE%BAdocker%E5%AE%B9%E5%99%A8%E5%86%85%E9%80%83%E9%80%B8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h1><p>最近，我们实验室的服务器遭到了校园网络中心的封禁。原因是服务器被发现感染了病毒，不仅被利用来挖掘加密货币，还攻击了其他在校园网内的服务器。让我们感到困惑的是，我们实验室的服务器架构相当严谨，由一个管理节点和三个GPU节点组成，管理平台更是基于docker的。我们在使用服务器进行运算时，其实是相当于开启了一个docker容器。在我的理解中，理论上，Docker的隔离特性应该能够防止病毒扩散到宿主机和其他容器。docker在设计上应该是一个隔离的环境，即使容器内部中了病毒，理论上也不应该能够影响到主节点或其他部分。我们只需简单地删除这个受感染的容器，问题就应该迎刃而解。<br>然而，实际情况却并非如此。我们尝试删除受感染的容器，但问题依然存在。这不禁让我们对Docker的安全性产生了疑问，也开始对背后的原因进行深入探索。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/22498321/1710770658470-e3433d10-8916-4283-9264-4dc39657243c.png"></p><h1 id="Docker容器的安全误区"><a href="#Docker容器的安全误区" class="headerlink" title="Docker容器的安全误区"></a>Docker容器的安全误区</h1><p>Docker容器技术被广泛认为能够提供良好的隔离，帮助在隔离的环境中运行应用程序，从而增强安全性。通过查阅资料和实验，我们逐渐了解到，虽然Docker容器在设计上是一个隔离的环境，但并不意味着它完全安全。如果攻击者能够利用某些漏洞或者配置不当，完全有可能从容器内部逃逸到宿主机，进而影响到影响到宿主机或者网络中的其他机器。</p><h1 id="探索和发现"><a href="#探索和发现" class="headerlink" title="探索和发现"></a>探索和发现</h1><p>在深入研究之后，我们发现了几个关键的安全问题和漏洞，这些可能是导致服务器被攻击的原因：</p><ol><li><strong>容器逃逸</strong>：如果攻击者能够利用某些漏洞（比如旧版Docker中的漏洞），他们可能会逃离容器的限制，访问宿主机操作系统。</li><li><strong>网络配置不当</strong>：Docker容器的网络配置如果设置不当，可能会让攻击者通过容器攻击到网络中的其他服务器。</li><li><strong>宿主机的安全性</strong>：如果宿主机的安全更新不及时，或者存在配置错误，也可能成为攻击的跳板。</li></ol><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>通过这次经历，我们学到了即使是在看似安全的容器化环境中，也存在着不容忽视的安全威胁。只有通过持续的学习、审计和改进，我们才能更好地保护我们的系统不受这些威胁的影响。<br>接下来，让我们通过一张插图来更直观地理解容器安全的重要性和实施的安全措施。</p><h1 id="Docker容器安全性探讨：从实验室服务器被攻击说起"><a href="#Docker容器安全性探讨：从实验室服务器被攻击说起" class="headerlink" title="Docker容器安全性探讨：从实验室服务器被攻击说起"></a>Docker容器安全性探讨：从实验室服务器被攻击说起</h1><p>近日，我们实验室使用的服务器被校园网络中心封禁。原因是服务器被发现感染了病毒，不仅被利用来挖掘加密货币，还攻击了其他在校园网内的服务器。<br>让我们感到困惑的是，我们实验室的服务器架构相当严谨，由一个管理节点和三个GPU节点组成，管理平台更是基于docker的。我们在使用服务器进行运算时，其实是相当于开启了一个docker容器。在我的理解中，理论上，Docker的隔离特性应该能够防止病毒扩散到宿主机和其他容器。docker在设计上应该是一个隔离的环境，即使容器内部中了病毒，理论上也不应该能够影响到主节点或其他部分。我们只需简单地删除这个受感染的容器，问题就应该迎刃而解。<br>然而，实际情况却并非如此。我们尝试删除受感染的容器，但问题依然存在。这不禁让我们对Docker的安全性产生了疑问，也开始对背后的原因进行深入探索。</p><h1 id="Docker容器技术简介"><a href="#Docker容器技术简介" class="headerlink" title="Docker容器技术简介"></a>Docker容器技术简介</h1><p>Docker容器技术以其高效、轻量的特点，成为了开发和运维中不可或缺的工具。它允许应用在隔离的环境中运行，提高了应用的可移植性和环境的一致性。然而，很多人误以为容器内的应用与主机系统完全隔离，但实际上，如果配置不当或存在漏洞，容器内的应用是有可能逃逸出来，影响宿主机或其他容器的。<br> 容器逃逸和安全风险<br>容器逃逸（Container Escape）是指在容器化环境中，恶意程序或攻击者绕过容器的隔离机制，从而获得访问宿主机系统或其他容器的能力。这种攻击方式能够让攻击者从一个受限的容器环境中“逃脱”出来，对整个系统造成更广泛的影响。</p><h1 id="容器检测"><a href="#容器检测" class="headerlink" title="容器检测"></a>容器检测</h1><p>首先是容器内的病毒需要检测是否位于容器内，从而检测是否需要逃逸。容器内的病毒或恶意软件判断是否需要逃逸，通常涉及到对其运行环境的分析和一系列的条件检测。其目的是评估逃逸的可能性、价值和风险，以确定进行逃逸攻击的最佳时机。以下是病毒可能采取的步骤和逻辑：</p><ol><li><p>环境侦察</p><ul><li><strong>操作系统和版本检测</strong>：病毒首先会检测宿主机的操作系统类型和版本，以确定是否存在已知的适用漏洞。</li><li><strong>容器管理工具识别</strong>：识别容器运行时环境（如Docker、Kubernetes等），了解其版本和配置，判断是否存在可利用的管理工具漏洞。</li><li><strong>权限级别评估</strong>：检查当前容器的权限级别，包括是否有root权限或其他高级权限，这将直接影响逃逸的难易度。</li></ul></li><li><p>漏洞和配置错误探测</p><ul><li><strong>搜索已知漏洞</strong>：病毒会搜索宿主机操作系统或容器运行时环境的已知漏洞，特别是那些可以用于提升权限或执行远程代码的漏洞。</li><li><strong>审计容器配置</strong>：检查是否存在错误配置，如不安全的挂载点、过度开放的网络配置或不必要的Linux功能（Capabilities）。</li></ul></li><li><p>监控和信号</p><ul><li><strong>监听环境变化</strong>：病毒可能会在背景静默监控，等待特定的环境变化或触发条件，如系统更新、配置变更或与外部控制服务器的通信。</li><li><strong>评估攻击价值</strong>：基于对环境的分析，病毒会评估逃逸的潜在价值，比如是否能够访问更多敏感数据或资源、是否有利于持久化控制等。</li></ul></li><li><p>风险评估</p><ul><li><strong>检测防御机制</strong>：病毒会探测宿主机和容器环境中的安全防御工具和机制，如SELinux、AppArmor或防病毒软件，评估逃逸行为可能触发的安全响应。</li><li><strong>计算被发现风险</strong>：评估执行逃逸操作被系统监控工具发现的风险，以及可能因此面临的对抗措施。</li></ul></li></ol><h1 id="实施决策"><a href="#实施决策" class="headerlink" title="实施决策"></a>实施决策</h1><p>基于上述评估，病毒将决定是否进行逃逸尝试。如果环境条件有利且逃逸的收益高于风险，病毒可能会选择执行逃逸。相反，如果逃逸风险高或环境条件不满足，病毒可能会选择继续在当前容器内活动，或者寻找其他方式影响系统。</p><h1 id="病毒逃逸"><a href="#病毒逃逸" class="headerlink" title="病毒逃逸"></a>病毒逃逸</h1><p>而当决定进行逃逸后，下面是一些常见的容器逃逸方法的详细介绍：</p><ol><li><p>滥用容器权限</p><ul><li><strong>利用高权限容器</strong>：如果容器以高权限（如root）运行，攻击者可能利用这些权限执行系统命令或安装恶意软件，进而实现逃逸。</li><li><strong>未限制的Linux功能</strong>（Capabilities）：Linux内核提供了一套功能位（Capabilities）来对进程的权限进行细粒度控制。如果容器配置允许过多的功能位，攻击者可能利用这些额外权限进行逃逸。</li></ul></li><li><p>容器运行时漏洞利用</p><ul><li><strong>Docker和容器管理工具漏洞</strong>：像Docker这样的容器管理工具如果存在安全漏洞，攻击者可以通过这些漏洞获得宿主机的控制权。例如，历史上曾发现过Docker Daemon的远程代码执行漏洞。</li><li><strong>内核漏洞</strong>：容器与宿主机共享相同的内核。如果内核存在漏洞，攻击者可能通过容器来利用这些漏洞，从而影响到宿主机系统。</li></ul></li><li><p>错误配置导致的逃逸</p><ul><li><strong>挂载敏感目录</strong>：如果容器错误地挂载了宿主机的敏感目录（如<code>/proc</code>、<code>/sys</code>），攻击者可以通过这些挂载点访问宿主机的敏感信息或修改系统配置。</li><li><strong>网络配置不当</strong>：错误的网络配置可能允许容器访问宿主机的网络接口或其他不应访问的网络资源。</li></ul></li><li><p>逃逸工具和技术</p><ul><li><strong>特殊工具和脚本</strong>：存在一些专为容器逃逸设计的工具和脚本，如<code>Shocker</code>等，它们可以自动化检测和利用环境漏洞来实现逃逸。</li><li><strong>Namespace切换</strong>：Linux的Namespace是实现容器隔离的关键技术。攻击者可能尝试切换或逃离当前Namespace，以获取对其他Namespace或宿主机的访问。</li></ul></li></ol><h1 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h1><ul><li><strong>最小权限原则</strong>：确保容器运行所需的最小权限，避免使用root权限运行容器。</li><li><strong>及时更新和打补丁</strong>：定期更新容器运行时环境和宿主机的操作系统，修复已知漏洞。</li><li><strong>安全配置和审计</strong>：仔细检查容器配置，避免敏感挂载，并使用工具进行安全审计。</li><li><strong>使用安全加固的容器基础镜像</strong>：使用已经过安全加固的容器基础镜像，减少容器内部的潜在攻击面。</li><li><strong>利用安全工具</strong>：使用如SELinux、AppArmor等安全模块增加额外的安全控制层面。<br>:::info<br>值得注意的是，这个过程可能高度自动化，且随着恶意软件技术的发展，病毒的检测和决策能力也在不断进步，容器逃逸技术的演变非常快。因此，维护容器和宿主机的安全，需要持续关注最新的安全威胁和防御技术。<br>:::</li></ul><h1 id="本次病毒操作的技术分析"><a href="#本次病毒操作的技术分析" class="headerlink" title="本次病毒操作的技术分析"></a>本次病毒操作的技术分析</h1><p>病毒通常利用容器内的高权限（例如root权限），通过特定的技术手段实现逃逸，进而对外部宿主机和其他容器进行攻击。这次事件中，病毒正是利用了我们平台对每个Docker容器分配的高权限进行逃逸和攻击。<br>我们的服务器是由一个管理节点和3个GPU节点组成，运行基于Docker的管理平台。本以为容器之间相互隔离，即使容器内有病毒，删除容器就能解决问题。然而，实际情况并非如此简单，这次事件暴露了我们在容器安全管理上的漏洞和配置不当。<br> 结论<br>Docker容器虽然为我们的开发和运维带来了便利，但也给安全管理带来了挑战。只有通过持续的学习、审计和实践，我们才能确保容器技术的安全使用。<br> <img src="https://cdn.nlark.com/yuque/0/2024/webp/22498321/1710770415891-62dcb74f-1456-4b4f-8f51-2b0f7d94d67b.webp" alt="容器攻击.webp"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker和docker-compose</title>
    <link href="/2023/12/27/%E5%9C%A8Docker%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8.env%E5%92%8Cdocker-compose%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B7%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/12/27/%E5%9C%A8Docker%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8.env%E5%92%8Cdocker-compose%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B7%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="现代微服务架构"><a href="#现代微服务架构" class="headerlink" title="现代微服务架构"></a>现代微服务架构</h1><p>在现代的云计算环境中，微服务的架构已经成为了一种常见的设计模式。微服务架构允许开发者将复杂的应用程序分解为一组小型、独立的服务，这些服务可以在各种环境中独立运行和扩展。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/22498321/1710067946199-3a16036a-1b13-4efb-a612-beff107495d4.png" alt="image-2.png">作为一个瞎折腾的玩家，我就是喜欢折腾各种新奇的玩意儿。最近，我在家里弄了两台小巧但是功能强大的ARM服务器，我在搭建我的服务时刚好需要让其中服务器1上的多个Docker容器能够访问服务器2中的相关服务。然而，这两台小家伙的IP地址和端口可能会随着网络环境的变化而变化，这就需要手动更改多个Docker容器的配置，这样每次重启服务器，或者更换网络就需要每个docker容器的配置文件都需要去修改，非常繁琐。</p><h1 id="使用配置文件简化后续迁移和管理"><a href="#使用配置文件简化后续迁移和管理" class="headerlink" title="使用配置文件简化后续迁移和管理"></a>使用配置文件简化后续迁移和管理</h1><p>我需要找到一种方法，可以让我在IP地址或端口变动时，能够_<strong>相对轻松</strong>_地更新Docker容器的配置。在我查了各种文档，尝试各种可能的解决方案后，我发现了.env和docker-compose文件，可以相对完美地解决我的问题。<br>.env文件和docker-compose文件是Docker环境中的两个强大工具，它们可以帮助我们更好地管理和配置我们的应用程序，使其能够在各种环境中运行和扩展。在接下来的内容中，我将详细介绍这两个工具的使用方法和作用。<br>在这篇文章中，我将介绍如何在Docker环境中，使用.env和docker-compose文件，实现跨服务器的服务访问。<br>首先，让我们来理解一下.env文件和docker-compose文件的作用。</p><h2 id="env-文件"><a href="#env-文件" class="headerlink" title=".env 文件"></a>.env 文件</h2><p>在我们的日常开发工作中，经常会遇到需要在不同的环境中使用不同的配置的情况。例如，开发环境和生产环境的数据库地址和密码可能会不同，或者我们可能需要根据当前的环境来决定是否开启某些调试功能。这时，我们就可以使用.env文件来帮助我们管理这些环境变量。<br>.env文件是一个简单的配置文件，用于存储环境变量。环境变量是在操作系统级别定义的，可以被运行在该操作系统上的应用程序访问。在Docker中，我们可以通过.env文件为容器提供环境变量，这些环境变量可以在容器启动时读取并使用。<br>例如，我们可以在.env文件中定义服务器的IP地址和端口：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># .env file</span><br><span class="hljs-attr">SERVER_IP</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.100</span><br><span class="hljs-attr">SERVER_PORT</span>=<span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>然后，在Docker容器中，我们可以通过环境变量SERVER_IP和SERVER_PORT来访问这些值。<br>这样，当我们需要更改这些配置时，只需要修改.env文件，而不需要修改使用这些环境变量的代码。这大大提高了我们的开发效率，并且可以避免因为忘记修改某个环境变量而导致的问题</p><h2 id="docker-compose文件"><a href="#docker-compose文件" class="headerlink" title="docker-compose文件"></a>docker-compose文件</h2><p>docker-compose是一个强大的工具，它允许开发者在一个单独的 docker-compose.yml 文件中定义和管理多个Docker容器。这个文件是一个YAML文件，它描述了你的应用程序的服务，网络和卷等信息。<br>docker-compose的一个主要优势在于它的便捷性和一致性。你可以在一个文件中定义整个应用的环境，而不是分别为每个容器写一个Dockerfile。这样，你可以一次启动、停止和重建所有的服务。这对于开发复杂的应用程序来说是非常有用的，因为这些应用程序可能由多个互相连接的服务组成。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-symbol">services:</span><br><span class="hljs-symbol">  web:</span><br><span class="hljs-symbol">    image:</span> nginx:latest<br><span class="hljs-symbol">    ports:</span><br>      - <span class="hljs-string">&quot;80:80&quot;</span><br><span class="hljs-symbol">  database:</span><br><span class="hljs-symbol">    image:</span> postgres:latest<br><span class="hljs-symbol">    volumes:</span><br>      - db_data:<span class="hljs-keyword">/var/</span>lib<span class="hljs-keyword">/postgresql/</span>data<br><span class="hljs-symbol">volumes:</span><br><span class="hljs-symbol">  db_data:</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个服务：一个web服务和一个database服务。web服务使用nginx镜像，把容器的80端口映射到主机的80端口。database服务使用postgres镜像，并且定义了一个卷来持久化数据库的数据。<br>docker-compose的另一个重要特性是，它可以读取.env文件中的环境变量，并在docker-compose.yml文件中使用这些环境变量。这使得我们可以在docker-compose.yml文件中使用.env文件中定义的环境变量，从而轻松地管理和配置跨服务器的服务访问。这极大地提高了应用程序的可移植性和扩展性。<br>在下一节，我们将详细介绍如何在docker-compose文件中使用.env文件中定义的环境变量。</p><h2 id="docker-compose中调用-env文件"><a href="#docker-compose中调用-env文件" class="headerlink" title="docker-compose中调用.env文件"></a>docker-compose中调用.env文件</h2><p>那么我们如何在docker-compose文件中使用.env文件中定义的环境变量呢？其实非常简单。<br>首先，我们需要在.env文件中定义我们需要的环境变量。然后，在docker-compose.yml文件中，我们可以使用${VARIABLE_NAME}的形式来引用这些环境变量，如下所示：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-symbol">services:</span><br><span class="hljs-symbol">  web:</span><br><span class="hljs-symbol">    image:</span> nginx:latest<br><span class="hljs-symbol">    ports:</span><br>      - <span class="hljs-string">&quot;$&#123;SERVER_PORT&#125;:80&quot;</span><br><span class="hljs-symbol">    environment:</span><br>      - SERVER_IP=$<span class="hljs-punctuation">&#123;</span>SERVER_IP<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，nginx服务将会监听在我们在.env文件中定义的SERVER_PORT，而SERVER_IP将会作为一个环境变量传递给nginx服务。<br>这就是在docker-compose文件中引用.env文件中的环境变量的方法。这种方法可以让我们在不修改docker-compose.yml文件的情况下，通过修改.env文件来改变容器的配置，使得管理和部署应用更加灵活和方便。<br>通过这种方式，我们可以轻松地在Docker环境中管理和配置跨服务器的服务访问。这不仅简化了配置过程，还提高了应用程序的可移植性和扩展性。<br>总的来说，.env文件和docker-compose文件是Docker环境中两个非常强大的工具。他们可以帮助我们更好地管理和配置我们的应用程序，使其能够在各种环境中运行和扩展。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用1Panel面板</title>
    <link href="/2023/12/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A81Panel%E9%9D%A2%E6%9D%BF/"/>
    <url>/2023/12/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A81Panel%E9%9D%A2%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>最近使用了香橙派的OrangePi5Plus构建了一个个人的迷你服务器</p><blockquote><p>OPi 5 Plus的SoC为 Rockchip RK3588 八核（4个Cortex-A76+4个Cortex-A55）架构的 64位处理器， 主频达 2.4GHz 并带有 Mali-G610 GPU，除此之外的亮点还包括了一个 6 TOPS 算力的 NPU，支持TensorFlow、PyTorch 等常见框架转换，使其能够作为处理 AI 影像的边缘装置。开发板上的周边也相当丰富，包含 2 Ports 2.5Gb Ethernet、3 Ports HDMI (2out + 1in)、5 Ports USB、 M.2 E-Key 等高速接口。从硬件数据看来相较树莓派而言可说是全面性的碾压，</p></blockquote><p>但是服务器运维往往会搭配一些管理工具以方便进行维护，尤其是有了像宝塔面板（BT Panel）这样的工具。作为市面上相对知名且大众化的服务器管理界面，宝塔面板提供非常直观和友善的界面对LAMP &#x2F; LNMP一类服务器技术栈进行管理，省去了许多在命令行中默默滚动的痛苦。</p><h1 id="1Panel：新的选择"><a href="#1Panel：新的选择" class="headerlink" title="1Panel：新的选择"></a>1Panel：新的选择</h1><p>但今天，我介绍另一个名为1Panel的管理面板，它是一种优秀且值得尝试的工具。<br>其实我一开始也使用过宝塔进行管理面板，但是个人感觉宝塔太臃肿了，而且界面并不好看，相比下1Panel有一些简单的优势</p><ol><li>开源：1Panel 强调开源开放，广泛获取社区使用反馈，并快速迭代。</li><li>现代化：一方面，1Panel 采纳最新的前端技术，并通过精心设计的UX 交互，为用户提供更好的用户使用体验；另一方便，1Panel 采用主流的容器技术，让 Linux 服务器的运维管理更简单、更安全。<blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/22498321/1707103761917-06d286f2-51e0-4d0b-9583-06649a126ddd.png"><br>1Panel官网的面板图片，感觉就更简洁现代</p></blockquote></li></ol><h1 id="1Panel初识：安装"><a href="#1Panel初识：安装" class="headerlink" title="1Panel初识：安装"></a>1Panel初识：安装</h1><p>1Panel的安装很简单，可以参考官网链接</p><p><a href="https://1panel.cn/docs/installation/online_installation/">在线安装 - 1Panel 文档</a><br>我在ubuntu下安装只需要使用下述命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">curl -sSL https://resource.fit2cloud.<span class="hljs-keyword">com</span>/<span class="hljs-number">1</span>panel/package/quick_start.<span class="hljs-keyword">sh</span> -<span class="hljs-keyword">o</span> quick_start.<span class="hljs-keyword">sh</span> &amp;&amp; sudo bash quick_start.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><p>但是界面会有安全入口设置，需要从网址<code>http://目标服务器 IP 地址:目标端口/安全入口</code>进入<br>安全入口可以通过ssh连接服务器后，使用<code>sudo 1pctl user-info</code>获取</p><h1 id="1Panel使用"><a href="#1Panel使用" class="headerlink" title="1Panel使用"></a>1Panel使用</h1><p>1Panel的使用还是蛮简单的，可以简单的上面进行一下常用软件的安装和docker管理等等~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于LPDDR3</title>
    <link href="/2023/12/18/%E4%BD%BF%E7%94%A8%E7%9A%84LPDDR3%E7%9A%84%E4%B8%80%E7%82%B9%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/12/18/%E4%BD%BF%E7%94%A8%E7%9A%84LPDDR3%E7%9A%84%E4%B8%80%E7%82%B9%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>我在制作的这个miniPC中，由于需要使用内存芯片，参考了解了一下市面上一些相关的内存芯片的选择。印象里，三星的内存芯片属于高性能、低功耗和可靠性的，在许多许多高端移动设备和嵌入式系统中是首选。所以这里我就大致简单的介绍一下这个芯片吧~（有点复杂，只能大致介绍一下了🥰）</p><h1 id="选择三星LPDDR3内存芯片的原因"><a href="#选择三星LPDDR3内存芯片的原因" class="headerlink" title="选择三星LPDDR3内存芯片的原因"></a>选择三星LPDDR3内存芯片的原因</h1><p>这里大致介绍一下LPDDR3吧</p><h2 id="技术规格和特点详解"><a href="#技术规格和特点详解" class="headerlink" title="技术规格和特点详解"></a>技术规格和特点详解</h2><h3 id="双数据率架构"><a href="#双数据率架构" class="headerlink" title="双数据率架构"></a>双数据率架构</h3><p>一种古老但仍然相关的实现数据传输速率大幅提高的技术称为”双泵” （double pumping）。K4E6E304ED-EGCG LPDDR3内存芯片采用了（DDR）架构，这意味着在每个时钟周期内，数据可以在上升沿和下降沿被捕获，从而使得数据传输速率翻倍。具体来说，这款芯片支持高达2133Mbps的传输速率，这为高速数据处理和大容量数据传输提供了强大的基础。<br><img src="https://cdn.nlark.com/yuque/0/2024/webp/22498321/1710820953715-6fa87b21-401f-4670-b982-aadc6e24f793.webp" alt="单数据速率存储器接口" title="单数据速率存储器接口"></p><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/22498321/1710820960233-6f8eedc9-6145-42ee-b731-8d56172299a3.webp" alt="双倍数据速率接口" title="双倍数据速率接口"></p><h3 id="低功耗设计"><a href="#低功耗设计" class="headerlink" title="低功耗设计"></a>低功耗设计</h3><p>在移动设备和其他电池供电的应用中，功耗是一个重要的考量因素。K4E6E304ED-EGCG支持1.2V的低电压操作，与前代产品相比，大大降低了功耗。</p><h3 id="高密度和大容量"><a href="#高密度和大容量" class="headerlink" title="高密度和大容量"></a>高密度和大容量</h3><p>K4E6E304ED-EGCG提供了16Gb的高密度存储空间，这个容量对于我目前的使用来说，还是够的，毕竟也只是个小主机~</p><h3 id="高效能的数据传输"><a href="#高效能的数据传输" class="headerlink" title="高效能的数据传输"></a>高效能的数据传输</h3><p>该芯片还支持连续读写操作和自动预充电选项，这进一步提升了数据传输的效率。自动预充电选项可以在每次数据传输后自动清空数据行，为下一次读写操作做好准备，从而减少了等待时间，优化了内存的响应速度。</p><h3 id="稳定性与可靠性"><a href="#稳定性与可靠性" class="headerlink" title="稳定性与可靠性"></a>稳定性与可靠性</h3><p>三星的内存，应该稳定性、可靠性方面还可以吧~K4E6E304ED具备了温度自适应功能，能够根据工作环境的温度变化自动调整工作频率和功耗，确保在不同的温度条件下都能稳定运行。此外，该芯片能够抵抗日常使用中可能遇到的各种物理和电气挑战，保证了长期的可靠性。</p><h3 id="兼容性考虑"><a href="#兼容性考虑" class="headerlink" title="兼容性考虑"></a>兼容性考虑</h3><p>考虑到兼容性，K4E6E304ED-EGCG遵循JEDEC标准，确保了它能够与各种主控芯片和平台集成。这一点对于开发者来说尤其重要，因为它降低了系统集成的复杂度，并缩短了产品上市的时间。<br>综上所述，Samsung K4E6E304ED-EGCG LPDDR3内存芯片以其高速、低功耗、大容量以及卓越的稳定性和兼容性，在众多应用场景中都能提供出色的性能表现。无论是在移动设备、嵌入式系统还是其他任何需要高性能内存解决方案的场合，它都是一个值得考虑的选择。</p><h2 id="技术特性与优势"><a href="#技术特性与优势" class="headerlink" title="技术特性与优势"></a>技术特性与优势</h2><ul><li><strong>更高的数据传输速率</strong>：相较于LPDDR2，LPDDR3的数据传输速率更高，可达到2133Mbps，这意味着更快的处理速度和更流畅的用户体验。</li><li><strong>低功耗设计</strong>：LPDDR3采用低功耗设计，有效延长了设备的使用时间。</li><li><strong>稳定性与兼容性</strong>：三星LPDDR3内存芯片在保证性能的同时，也提供了极高的稳定性和良好的兼容性。</li></ul><h2 id="比较分析"><a href="#比较分析" class="headerlink" title="比较分析"></a>比较分析</h2><p>与LPDDR2相比，LPDDR3在许多关键指标上都有所提升。除了速度和功耗之外，LPDDR3还改进了数据信号的设计，减少了信号干扰，提高了数据传输的准确性。这对于数据密集型的应用尤为重要。</p><h1 id="项目中的集成与应用"><a href="#项目中的集成与应用" class="headerlink" title="项目中的集成与应用"></a>项目中的集成与应用</h1><p>内存芯片的设计规则往往比较复杂~</p><h2 id="布局要求："><a href="#布局要求：" class="headerlink" title="布局要求："></a>布局要求：</h2><ol><li>DDR3颗粒之间的间距根据实际情况调整，建议DDR3丝印框间距2~3mm为宜。</li><li>DDR3一般采用“Fly-By”拓扑结构，数据位端靠近控制器摆放。并且按数据线按照低位到高位（高位到低位）依次排列。</li><li>终端电阻放置在最后一片数据高位的末端，并且位置控制在700mil以内。</li><li>VTT&#x2F;VREF电源芯片尽量靠近终端电阻摆放，尽量满足表层铺铜，并且相关电源滤波电容尽量靠近DDR3电源管脚摆放 。</li><li>时钟线并联端接100ohm电阻放置于最后一片数据高位处，长度尽量短。</li><li>具有ECC校验时，校验位放置于第一片。此处的反射最大。</li></ol><h2 id="阻抗要求："><a href="#阻抗要求：" class="headerlink" title="阻抗要求："></a>阻抗要求：</h2><ol><li>单线阻抗：DDR3所有单端信号，主线阻抗控制40欧姆、负载阻抗60欧姆；</li><li>差分阻抗：数据选通信号、时钟信号差分阻抗控制85欧姆</li></ol><h3 id="时钟布线要求："><a href="#时钟布线要求：" class="headerlink" title="时钟布线要求："></a>时钟布线要求：</h3><ol><li>差分布线，差分阻抗85欧姆，差分线对内误差±5mil；</li><li>所有DDR 的差分时钟线CK 与CK#尽量在同层布线，CLK 对内±5mil等长；</li><li>与其它信号的边缘间距要大于25mil；</li><li>时钟线与DQS的无等长要求。</li></ol><h3 id="数据组布线要求："><a href="#数据组布线要求：" class="headerlink" title="数据组布线要求："></a>数据组布线要求：</h3><ol><li>DQS&#x2F;DQS#为差分布线。差分线误差±5mil，差分阻抗85 欧姆；</li><li>同组信号Data、 Data strobe 、 Data mask同层走线。以GND为参考平面回流，不跨平面分割，组内长度之间误差为±5mil；</li><li>同信道的DQS一般走线在DQ 中间；DQS与其他信号间距控制尽量在4W。同组内DQ 与DQM 以DQS 为基准等长。</li><li>LANE Group之间等长要求差为800mil ；</li></ol><h3 id="地址控制命令组布线要求："><a href="#地址控制命令组布线要求：" class="headerlink" title="地址控制命令组布线要求："></a>地址控制命令组布线要求：</h3><ol><li>按“Fly-By”拓补走线，并且DDR3互连处尽量在同层布线，保证其传输环境的一致性。</li><li>参考平面可选择Ground或Power。不可跨越分割槽，为提供完整的低阻抗回流路径。</li><li>Address 、Control 、Command从控制器到每一片DDR3组内误差为±10mil。</li><li>Address 、Control 、 Command与Ck等长即可</li></ol><h3 id="电源完整性："><a href="#电源完整性：" class="headerlink" title="电源完整性："></a>电源完整性：</h3><ol><li>VDD：<br>容差要求是5%，通过电源层的平面电容和专用的一定数量的去耦电容，可以做到电源完整性。</li><li>VTT：<br>a. 用于端接地址、命令、 控制信号线，VTT 用Rt 端接地址&#x2F;控制&#x2F;命令信号线，VTT&#x3D;VDDQ&#x2F;2&#x3D;0.75V；并不端接时钟线，具有很大的瞬间电流，最终可以通过增加去耦电容的数量来实现目标阻抗匹配。<br>b. 走线宽度：峰值电流可以达到3.5A，建议在表层大面积的孤岛铺铜，宽度至少150mil。<br>c. 上拉电阻：常用排阻，通常直接放置在VTT铜皮上就近打孔。<br>d. 去耦电容：每4个电阻（或一个排阻）放置一个去耦电容，常用0.1uF。<br>e. 储能电容：在VTT孤岛铜两端各放置两个电容，常用4.7uF、220uF电容</li><li>VREF：<br>a. 产生电路参考电压，需求的电流相当小，小于3mA，但是需要确保VREF的AC Noise保持在±25mv。否则会引起时序的误差以及抖动等不确定的行为。<br>b. 走线宽度：建议20mil~25mil。<br>c. 走线间距：建议20mil以上。<br>d. 去耦电容：尽量靠近器件的管脚摆放，常用100nF和1nF。<br>注：VTT 与VREF 走线在同一层，必须具有150mil的距离，推荐它们在不同层</li></ol><h1 id="剩余"><a href="#剩余" class="headerlink" title="剩余"></a>剩余</h1><ul><li>其他的，后面做完再补充吧~</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于肌肉、骨骼密度检测</title>
    <link href="/2023/10/17/%E8%82%8C%E8%82%89%E3%80%81%E9%AA%A8%E9%AA%BC%E5%AF%86%E5%BA%A6%E6%A3%80%E6%B5%8B/"/>
    <url>/2023/10/17/%E8%82%8C%E8%82%89%E3%80%81%E9%AA%A8%E9%AA%BC%E5%AF%86%E5%BA%A6%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>最近实验室医疗相关，了解了一些关于肌肉和骨骼密度检测</p><h1 id="骨骼密度检测方法"><a href="#骨骼密度检测方法" class="headerlink" title="骨骼密度检测方法"></a>骨骼密度检测方法</h1><ol><li>双能X线吸收法（DXA）。该方法目前较为可靠，包括腰椎、手腕关节等各种，测量较为可靠，是WHO发布的骨质疏松诊断标准</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/22498321/1710770934658-6f06d02a-d7db-443f-90c8-22c63c4783b4.png" alt="image.png"><br>2. 定量CT骨密度测量（QCT）。利用CT影像，可以测量三维骨密度测量</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/22498321/1710770944987-db689bf6-422c-4032-a860-8e0878374625.png" alt="image.png"><br>3. <strong>超声检查。应用较少，目前市面也有价格较低的成品仪器设备。利用超声的速度和衰减对骨密度进行评估。应用比较困难，仅仅作为骨质疏松的初步筛查，同时主要基本用于测量足跟部的骨密度。</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/22498321/1710770966605-d692ceda-bcaf-4c97-95e9-cd35aef8b258.png" alt="image.png"># 肌肉密度检测方法</p><ol><li>生物电阻抗分析 (BIA)：向用户施加交流电流，通过阻抗值测定体内水分。电流的流动将受到体内水分的影响。BIA装置测定的就是电流信号如何受到不同类型组织的阻碍（肌肉具有高传导性，但脂肪可使信号减慢）。BIA确定电流通过身体时的流动阻力后，估算出体脂量</li><li>核磁共振成像（MRI）：Structure MRI（结构性磁共振成像）通常用于获取高分辨率的人体组织结构图像。，包括肌肉密度和组织构成等。</li><li>双能 X 射线吸收法（DEXA）： X 射线扫描身体，并详细评估你的肌肉量和脂肪量，以及脂肪和肌肉在你身上的分布情况。</li><li>计算机断层扫描（CT）：CT扫描可以提供肌肉组织的详细三维图像，可以用来测量肌肉密度和体积。</li></ol><blockquote><p>使用超声难以实现对肌肉密度的检测，由于超声测量骨密度时，需要测量骨骼的厚度等信息。但是利用超声穿透肌肉并反射的时间差进行肌肉密度的检测时，无法测量得到检测时刻的肌肉厚度，因此无法通过时间差计算速度差<br>骨密度、肌密度检测方法：<br>使用<strong>双能X线吸收法</strong>，通过X射线扫描的方式，相对较为可行，通过可以评估出肌肉等组织的分布情况以及骨骼密度，结果应该更为可靠</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>STM32 使用DMA MEMTOMEM</title>
    <link href="/2023/09/10/DMA%20%E7%9A%84MEMTOMEM/"/>
    <url>/2023/09/10/DMA%20%E7%9A%84MEMTOMEM/</url>
    
    <content type="html"><![CDATA[<p>最近有一个特殊的需求：之前进行超声脉冲激励控制时，主要采用了一款装用的双通道脉冲输出芯片，因为需要实现一个双通道互补的50%PWM脉冲输出，而且要精准的控制触发时间和占空比，同时还要控制两个通道的相位。由于目前使用的超声是10Mhz的，要实现这么<strong>高频的，可控制精准占空比、多通道相位同步控制，</strong>使用一般的方式还是有点难度的。因此需要重新考虑怎么操作。</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ol><li>超声的脉冲发生中，高压脉冲发生器STHV748需要两个高速的控制信号驱动</li></ol><p>过去使用LM96570波形发生器，用于产生控制信号。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1697354618729-5cf8aa75-42ea-4953-a279-85fbab1b17db.png" alt="image.png"></p><ol start="2"><li>由于产生的超声脉冲频率达到10MHz，而每半个波长就需要产生一次控制信号，因此需要20MHz的高频控制信号，同时需要准确控制脉冲个数</li><li>STM32h7的主频使用240mhz的情况下，产生20MHz的控制方波信号，则每次切换<strong>只有12个时钟周期</strong>的时间，间隔极短，因此不能依赖传统的PWM精确脉冲控制的方式。</li><li><strong>不能使用任何中断控制等方式</strong>，同时需要考虑指令的执行时间<blockquote><p>使用STM32的中断响应的方式，需要等待至少12个时钟周期，同时完成中断响应实现中断触发-压栈-中断向量表-进入中断处理函数等过程，需要执行很多个指令的。一旦使用HAL库，或者在中断中进行其他运算，会超出需求的时间间隔，影响输出脉冲。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1697355327694-ec9c4498-0a86-4e88-8cd7-98d6817ecf48.png"></p></blockquote></li></ol><p><strong>因此需要实现在无CPU参与情况下的高频指定脉冲数输出，那这就不得不使用DMA方式了~</strong></p><h1 id="DMA-基础"><a href="#DMA-基础" class="headerlink" title="DMA 基础"></a>DMA 基础</h1><p>DMA是一种允许外设和内存之间直接传输数据的技术，无需CPU的介入，从而释放CPU资源以处理其他任务。在STM32微控制器中，DMA控制器支持多种数据传输模式，包括MEMTOMEM模式，该模式允许内存区域之间直接传输数据。</p><p>DMA（Direct Memory Access）MEMTOMEM模式是DMA传输模式之一，它允许数据从一个内存区域直接传输到另一个内存区域，而不需要CPU的介入。这种模式在处理大量数据传输时特别有用，因为它可以减轻CPU的负担，提高系统的整体效率。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>在STM32微控制器中，DMA控制器支持多种传输模式，包括MEMTOMEM模式。以下是MEMTOMEM模式的详细介绍：</p><h2 id="关于DMA-MEMTOMEM模式"><a href="#关于DMA-MEMTOMEM模式" class="headerlink" title="关于DMA MEMTOMEM模式"></a>关于DMA MEMTOMEM模式</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>在MEMTOMEM模式下，DMA控制器负责在两个内存区域之间传输数据。DMA控制器会根据预设的参数，如数据大小、传输方向、缓冲区大小等，自动处理数据的移动。CPU在初始化DMA传输后，可以执行其他任务，直到DMA传输完成。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>无需CPU干预</strong>：一旦DMA传输开始，CPU不需要参与数据的实际移动过程。</li><li><strong>高效</strong>：DMA传输不会占用CPU周期，因此CPU可以同时处理其他任务。</li><li><strong>灵活</strong>：用户可以根据需要设置传输的数据量、方向和目标内存地址。</li><li><strong>中断支持</strong>：DMA控制器可以在传输完成或发生错误时，通过中断通知CPU。</li></ul><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><p>要在STM32中配置DMA MEMTOMEM传输，通常需要执行以下步骤：</p><ol><li><strong>使能DMA控制器和相关外设的时钟</strong>：通过RCC（Reset and Clock Control）模块来使能DMA和需要使用DMA的外设的时钟。 </li><li><strong>初始化DMA通道</strong>：通过STM32CUBEMX配置DMA通道的参数，包括内存源地址、外设目标地址、数据方向、数据大小、传输模式（如循环模式）、优先级等。 </li><li><strong>设置内存源地址和外设目标地址</strong>：内存源地址指向数据的起始位置，外设目标地址通常设置为外设的控制寄存器地址，但在MEMTOMEM模式下，外设地址通常设置为一个固定的地址，如STM32中的<code>0xFFFF0800</code>，这是一个特殊的地址，用于表示内存到内存的传输。 </li><li><strong>启动DMA传输</strong>：通过调用DMA_Cmd函数启用DMA传输。 </li><li><strong>配置中断（可选）</strong>：如果需要，可以配置DMA中断，以便在传输完成或发生错误时得到通知。</li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>MEMTOMEM模式在以下场景中特别有用：</p><ul><li><strong>数据处理</strong>：在需要处理大量数据时，如图像处理、音频数据处理等。</li><li><strong>数据复制</strong>：从一个内存区域复制数据到另一个内存区域，例如在准备数据块以供外设使用时。</li><li><strong>实时系统</strong>：在需要快速响应和高吞吐量的实时系统中，DMA可以确保数据及时传输，同时CPU可以处理其他关键任务。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保内存源地址和目标地址有效，且内存区域已经正确配置。</li><li>在MEMTOMEM模式下，外设地址通常设置为特定的值，而不是实际的外设寄存器地址。</li></ul><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>使用一个较长的数组，用于存储GPIO口的ODR寄存器数值，使用** DMA 的MEMTOMEM 实现对GPIO-&gt;ODR的直接修改**，完成对GPIO的高速以及指定脉冲数控制</p><ul><li>出现DMA state一直busy， 后发现使用HAL_DMA_Start_IT ，由于使用HAL_DMA_Start并不会清除DMA标志位，导致在normal模式下只能实现单次的脉冲，此后无脉冲输出</li></ul><p>在使用F103的情况下可以实现多个持续脉冲的输出<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/22498321/1697254640722-f87fc8bb-1f29-4380-834e-e268c3a23280.jpeg"><br>但是使用STM32H7后出现了波形间隔的问题<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/22498321/1697254582072-7d47f30d-e4da-4ce2-a43b-d2f90a84d2dd.jpeg"></p><p>缺点： </p><ul><li>使用该方式需要使用<strong>系统时钟AHB</strong>作为DMA直接时钟源，需要通过修改数组的具体内容实现对输出频率的调节。</li><li>同时使用H7时出现上图的波形间断的问题</li><li>原因：在H7下，使用DMA的MEMTOMEM模式下，<strong>需要使用FIFO</strong>，但是 DMA1和DMA2带的FIFO是4个32bit的空间，即16字节。因此如上图所示会在进行16次翻转（8个脉冲）后出现需要移动FIFO指针位置等操作，因此出现了时间间隔</li></ul><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><p>使用定时器的TIM输出，同时配合使用DMA模式，实现高速修改TIM的CCR寄存器，用于控制PWM波的可调脉冲输出，并可以配合CH1和CH1N实现互补通道输出，方便产生控制信号<br>问题：<br>使用DMA搬运时，由于不同通道分开实现搬运，由于实验所需的<strong>脉冲搬运速度过快</strong>，会由于DMA的速度，导致不同通道存在一定的波形错开，无法实现同步的对齐，因此不可用。</p><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><p>使用DMAMUX+TIM的方式实现可调频、可调波数的输出。<br>在DMAMUX下，使用指定时钟信号，触发DMA，避免通过调节系统时钟完成调频，方便了输出，结果如下<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/22498321/1697254712873-bf4f641e-e567-4654-bc9f-3cb147ee6cfa.jpeg"></p><h4 id="DMAMUX"><a href="#DMAMUX" class="headerlink" title="DMAMUX"></a>DMAMUX</h4><p>DMAMUX取消了原先DMA模式下，只能由有限固定的触发源请求DMA，可以使用更广泛，如定时器等<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/22498321/1697266274745-284eefa9-b6ad-46b4-bea2-59b7cbbbb57d.webp"></p><ul><li><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/22498321/1697266274745-284eefa9-b6ad-46b4-bea2-59b7cbbbb57d.webp"></p><ul><li>——原先基础的DMA表</li></ul></li><li><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/22498321/1697266260319-e245cd56-455b-4ddc-9c2f-6b7c1986a958.webp"></p><ul><li>——使用DMAMUX后可以实现的DMA请求和功能的管理<blockquote><p>通过DMA请求生成器基于触发信号生成DMA请求，一方面可以弥补只是部分外设事件【dmamux_req_inx】才可以申请DMA传输的局限，另一方面可以将不同DMA请求借助路由器模块输出的路由事件【dmamux_evtx】关联起来，让DMA应用更为灵活并富有创意。</p></blockquote></li></ul></li><li><p>对比使用<strong>双缓冲模式和单缓冲模式</strong>，配合分别均可实现高速的脉冲输出，双缓冲模式下，脉冲输出时可以方便对数组值进行修改，即后续GPIO的状态进行调整</p></li><li><p>使用实现了正确的脉冲输出，及脉冲数控制，以及指定间隔时间下的脉冲输出</p><ul><li><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/22498321/1697280385211-a0963176-53bc-4f8e-bc51-a4095eb2fec4.jpeg" alt="a61af138018bbeef639d431f52d8294.jpg"></li></ul></li><li><p>DMA改为使用定时器TIM12作为时钟源进行上升下降沿触发，这样可以只需要修改定时器的占空比，DMA只负责切换即可，即数组只是用最简单的交替切换，而不再用于控制占空比。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/22498321/1697280520158-1b890cf3-eecd-46e3-8b40-3a5de0d48ff4.jpeg"></p><ul><li>实测中TIM第一次触发DMA的数据会有部分时候的时长不同，因此选择先置零实现控制。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/22498321/1697280570173-74ac419b-98c7-47ef-92a0-545d7b6e3863.jpeg"></p><ul><li>从图中可以看到，已经实现了对应方波的控制了，可以先拉丁电平，再控制交替的高电平切换，以及精准脉冲数目的控制了！</li><li>相关的STM32CUBE内的配置情况如下</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1697358370284-b0f78479-bace-47a0-b02b-ac9a6c4a71c0.png" alt="image.png"></li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1697358392130-09093f63-b1d1-4ab6-8bb7-cd5cabaf7922.png" alt="image.png"></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt分享</title>
    <link href="/2023/06/08/%E5%85%B3%E4%BA%8EQt/"/>
    <url>/2023/06/08/%E5%85%B3%E4%BA%8EQt/</url>
    
    <content type="html"><![CDATA[<p>最近和实验室师兄们做了一个Qt分享会，在这里也分享一下相关的内容<br>![]</p><h1 id="Qt简介"><a href="#Qt简介" class="headerlink" title="Qt简介"></a>Qt简介</h1><p>Qt是一个跨平台的C++，python应用程序框架，被广泛用于开发GUI应用程序，同时也能用于开发非GUI程序，如控制台工具和服务器。Qt的一个主要特点是其信号和槽机制，这个机制使得它在设计模式实现上有着独到之处。此外，Qt支持多平台开发，包括Windows、Linux、Mac OS X等。<img src="https://cdn.nlark.com/yuque/0/2024/png/22498321/1710772147811-0531a3a3-07ea-474d-9016-f207185cc0de.png" alt="摘取自Qt官网" title="摘取自Qt官网"></p><h1 id="Qt与其他GUI框架的对比"><a href="#Qt与其他GUI框架的对比" class="headerlink" title="Qt与其他GUI框架的对比"></a>Qt与其他GUI框架的对比</h1><ul><li><strong>与MFC的对比：</strong> MFC是微软提供的一个用于Windows应用开发的框架。与Qt相比，MFC主要局限于Windows平台，而Qt支持跨平台开发。此外，Qt提供了更加现代的API和更丰富的控件集。</li><li><strong>与WPF的对比：</strong> WPF是Windows平台上的一种新型GUI框架，它基于.NET Framework。WPF支持丰富的UI功能和动画，但是它不是跨平台的。Qt虽然在动画和UI特效方面不如WPF，但在跨平台和性能方面具有优势。</li><li><strong>与Java Swing&#x2F;AWT的对比：</strong> Swing和AWT是Java的GUI开发库。它们是跨平台的，但在性能和外观上通常不如Qt，特别是在原生外观和感觉上。</li></ul><h1 id="信号与槽机制"><a href="#信号与槽机制" class="headerlink" title="信号与槽机制"></a>信号与槽机制</h1><p>信号与槽是Qt框架中对象之间通信的一种机制，广泛应用于事件驱动程序中。这个机制使得组件之间的通信变得更加灵活和解耦。</p><ol><li><p><strong>传统的connect方式（Qt4）</strong><br>这是Qt4及之前版本中使用的信号和槽连接方式。它通过字符串来匹配信号和槽，虽然清晰但存在一些弊端，比如类型安全问题和运行时错误的可能。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">connect</span>(ui-&gt;pushButton, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">pushButton1_clicked</span>()));<br></code></pre></td></tr></table></figure></li><li><p><strong>函数指针connect方式（Qt5）</strong><br>Qt5引入了基于函数指针的连接方式，提高了类型安全性，并在编译时就能发现错误，相比于Qt4的方式更加简洁和安全。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">connect</span>(ui-&gt;pushButton_2, &amp;QPushButton::clicked, <span class="hljs-keyword">this</span>, &amp;MainWindow::pushButton2_clicked);<br></code></pre></td></tr></table></figure></li><li><p><strong>带参数的信号与槽</strong><br>当信号和槽函数需要参数时，可以使用<code>static_cast</code>来指定参数类型，或者使用<code>QOverload</code>来解决重载问题。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">connect</span>(ui-&gt;pushButton_2, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-built_in">void</span> (QPushButton::*)(<span class="hljs-type">bool</span>)&gt;(&amp;QPushButton::clicked), <span class="hljs-keyword">this</span>, &amp;MainWindow::pushButton2_clicked);<br><span class="hljs-built_in">connect</span>(ui-&gt;pushButton_3, QOverload&lt;<span class="hljs-type">bool</span>&gt;::<span class="hljs-built_in">of</span>(&amp;QPushButton::clicked), <span class="hljs-keyword">this</span>, &amp;MainWindow::pushButton3_clicked);<br></code></pre></td></tr></table></figure></li><li><p><strong>Lambda表达式</strong><br>使用Lambda表达式可以让连接信号和槽的代码更加灵活和紧凑，特别是在需要简单回调时。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">connect</span>(ui-&gt;pushButton_4, QOverload&lt;<span class="hljs-type">bool</span>&gt;::<span class="hljs-built_in">of</span>(&amp;QPushButton::clicked), [=](<span class="hljs-type">bool</span> checked)&#123;<br>    ui-&gt;textBrowser-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;按钮4信号绑定成功&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><h1 id="不同多线程实现方式"><a href="#不同多线程实现方式" class="headerlink" title="不同多线程实现方式"></a>不同多线程实现方式</h1><p>在Qt中，有多种方式实现多线程程序，这些方式各有优缺点和适用场景。</p><ol><li><p><strong>QThread类的继承</strong><br>通过继承<code>QThread</code>类并重写其<code>run</code>方法，可以实现比较传统的线程功能。这种方式适合长时间运行的任务，但需要手动管理线程的创建和销毁。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerThread</span> : <span class="hljs-keyword">public</span> QThread &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 复杂的操作...</span><br>        <span class="hljs-function">emit <span class="hljs-title">resultReady</span><span class="hljs-params">(result)</span></span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>QThread的moveToThread</strong><br>这是一种更加现代和灵活的方式，将任务对象移动到线程中执行。这种方式避免了直接继承<code>QThread</code>的复杂性，使得线程的使用更加灵活。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> : <span class="hljs-keyword">public</span> QObject &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;parameter)</span> </span>&#123;<br>        <span class="hljs-comment">// 复杂的操作...</span><br>        <span class="hljs-function">emit <span class="hljs-title">resultReady</span><span class="hljs-params">(result)</span></span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>QtConcurrent</strong><br><code>QtConcurrent::run</code>是一个高级API，允许以并行方式执行函数或成员函数。这种方式简化了多线程程序的编写，特别适用于那些可以自动管理线程数量的情况。</p></li></ol><h1 id="推荐的Qt开发工具"><a href="#推荐的Qt开发工具" class="headerlink" title="推荐的Qt开发工具"></a>推荐的Qt开发工具</h1><ul><li>Qt Creator： Qt Creator是Qt官方推荐的开发环境，它提供了代码编辑、界面设计、调试和版本控制等功能，非常适合Qt项目的开发。</li><li>Visual Studio + Qt插件： 对于习惯使用Visual Studio的开发者，可以通过安装Qt插件来进行Qt应用的开发，这样结合了Visual Studio强大的开发功能和Qt的跨平台特性。个人更喜欢这种方法开发（主要式Visual Studio好用呀！）</li></ul><h1 id="界面美化"><a href="#界面美化" class="headerlink" title="界面美化"></a>界面美化</h1><p>Qt支持通过样式表（QSS）来自定义控件的外观，使得界面美化变得简单而强大。样式表的语法类似于CSS，可以轻松实现控件的个性化定制。</p><ul><li><strong>直接在Qt Designer中设置样式</strong><br>可以在Qt Designer的属性编辑器中直接设置控件的样式表。 </li><li><strong>在代码中动态设置样式</strong></li></ul><p>通过<code>setStyleSheet</code>方法可以在代码中设置控件的样式，这提供了更大的灵活性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setStyleSheet</span>(<span class="hljs-string">&quot;QPushButton &#123; background-color: red; &#125;&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>使用QSS样式表文件</strong><br>将样式定义在外部的<code>.qss</code>文件中，然后在应用程序中加载这个文件，可以使得样式管理更加集中和方便。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/gif/22498321/1710772334184-89df71d9-1585-41d7-bb75-bd2ad584aa0d.gif" alt="Qt.gif"></p><h1 id="Qt开发中的注意点"><a href="#Qt开发中的注意点" class="headerlink" title="Qt开发中的注意点"></a>Qt开发中的注意点</h1><ul><li><strong>内存管理：</strong> 在Qt中使用对象时，需要注意对象的父子关系，这关系会影响到对象的销毁。Qt的对象树可以自动管理对象的生命周期，避免内存泄漏。</li><li><strong>信号与槽的使用：</strong> 正确使用信号与槽是Qt编程中的关键。需要注意信号与槽的匹配问题，以及避免循环信号。</li><li><strong>跨平台开发的考虑：</strong> 虽然Qt支持跨平台开发，但在不同平台上可能存在细微的差异，如文件路径、编码等。开发时需注意这些差异，确保应用在各平台上都能正常运行。</li><li><strong>性能优化：</strong> 对于复杂的UI或高性能要求的应用，需要合理使用线程、避免阻塞UI线程、优化绘图操作等，以确保应用的响应性和流畅性。</li></ul><blockquote><p>Qt是一个功能丰富的跨平台框架，提供了强大的GUI编程能力。通过理解和应用信号与槽机制、多线程处理以及界面美化技术，可以开发出既强大又美观的应用程序。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于TCP/UDP</title>
    <link href="/2023/06/08/%E5%85%B3%E4%BA%8ETCP_UDP/"/>
    <url>/2023/06/08/%E5%85%B3%E4%BA%8ETCP_UDP/</url>
    
    <content type="html"><![CDATA[<p>由于实验室有个需要我负责的项目，主要是基于A超、IMU和肌电的多模态联合采集设备的设计和制作。考虑到信号传输的实时性、稳定性以及数据的准确性，探讨了不同的传输方案。需要考虑一下是采用传统的有线传输还是现代的无线传输技术，以确保信号能够准确无丢失地传输，为后续的数据分析和应用提供支撑。🤷‍♂️<br>这里先探讨一下关于TCP和UDP的部分内容吧</p><h1 id="一、TCP和UDP协议简介"><a href="#一、TCP和UDP协议简介" class="headerlink" title="一、TCP和UDP协议简介"></a>一、TCP和UDP协议简介</h1><p><strong>传输控制协议（TCP）</strong>和<strong>用户数据报协议（UDP）</strong>是互联网中两种最常用的传输层协议。它们都用于数据的发送和接收，但是各有特点和应用场景。</p><ul><li><strong>TCP</strong> 是一种面向连接的、可靠的、基于字节流的传输层通信协议。它能够保证数据的顺序传输和数据完整性，非常适合对数据准确性要求高的应用。TCP通过**<em>三次握手</em><strong>建立连接，</strong><em>四次挥手</em>**断开连接，提供拥塞控制、流量控制等机制，确保数据传输的可靠性和稳定性。 </li><li><strong>UDP</strong> 是一种无连接的传输协议，提供了一种简单的方式来发送封装的数据报文。与TCP相比，UDP不保证消息的顺序、重复和完整性，但它的优势在于**<em>低延迟和低开销</em>**，适用于对实时性要求高的应用，如视频会议、在线游戏等。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/22498321/1710816110321-0dbff2fd-022e-495f-9bd6-f4a301109301.png"></li></ul><h2 id="TCP和UDP的基础"><a href="#TCP和UDP的基础" class="headerlink" title="TCP和UDP的基础"></a>TCP和UDP的基础</h2><h3 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h3><ul><li><strong>工作原理</strong>：TCP提供一种可靠的服务，通过三次握手过程建立连接，确保数据的有序传输和错误检测。数据以字节流的形式发送，确保每个字节都按顺序到达。 </li><li><strong>特点</strong>： <ul><li>可靠性：通过序列号、确认应答、超时重传等机制保证数据完整性和顺序性。</li><li>流量控制：利用滑动窗口机制控制发送速率，避免接收方处理不过来。</li><li>拥塞控制：根据网络条件动态调整数据的发送速率，减少网络拥塞。</li></ul></li><li><strong>应用场景</strong>：适用于要求高可靠性的应用，如网页浏览（HTTP&#x2F;HTTPS）、文件传输（FTP）、电子邮件（SMTP&#x2F;POP3）等。</li></ul><h3 id="UDP（用户数据报协议）"><a href="#UDP（用户数据报协议）" class="headerlink" title="UDP（用户数据报协议）"></a>UDP（用户数据报协议）</h3><ul><li><strong>工作原理</strong>：UDP是一种简单的无连接协议，提供尽最大努力的服务。数据被封装成数据报进行发送，但不保证顺序、重复和完整性。 </li><li><strong>特点</strong>： <ul><li>高效率：没有建立连接的过程，减少了通信的延迟。</li><li>灵活性：允许一对一、一对多、多对一和多对多的交互通信。</li><li>不可靠性：不保证数据包的顺序、重复和完整性，可能需要应用层来实现这些功能。</li></ul></li><li><strong>应用场景</strong>：适合对实时性要求高的应用，如视频会议、在线游戏、语音传输（VoIP）等。</li></ul><h3 id="TCP和UDP的高级话题"><a href="#TCP和UDP的高级话题" class="headerlink" title="TCP和UDP的高级话题"></a>TCP和UDP的高级话题</h3><h4 id="TCP优化技巧"><a href="#TCP优化技巧" class="headerlink" title="TCP优化技巧"></a>TCP优化技巧</h4><ul><li><strong>TCP快速打开（TFO）</strong>：减少建立连接所需的往返时间，加快数据的传输。</li><li><strong>TCP无延迟（Nagle算法的禁用）</strong>：对于要求实时性的应用，禁用Nagle算法可以减少数据传输的延迟。</li></ul><h4 id="UDP的现代应用"><a href="#UDP的现代应用" class="headerlink" title="UDP的现代应用"></a>UDP的现代应用</h4><ul><li><strong>QUIC协议</strong>：基于UDP开发的传输层协议，结合了TCP的可靠性和UDP的高效性。它支持多路复用、流控制、拥塞控制等特性，正在被HTTP&#x2F;3使用。</li></ul><p>TCP和UDP各有优缺点，理解它们的工作原理和特性能帮助我们更好地选择适合特定场景的协议。在实际应用中，可能还需要结合应用层的需求，进行协议的选择和优化，以满足性能和可靠性的双重要求。在多模态生物信号采集等高精度、实时性要求的场景中，恰当地利用TCP和<br>UDP的特性，可以极大地提高数据传输的效率和准确性。</p><h1 id="二、多模态生物信号采集与TCP-UDP"><a href="#二、多模态生物信号采集与TCP-UDP" class="headerlink" title="二、多模态生物信号采集与TCP&#x2F;UDP"></a>二、多模态生物信号采集与TCP&#x2F;UDP</h1><p>在多模态生物信号采集设备，如实验室制作的A型超声等设备中，数据采集、处理和传输是核心任务之一。根据应用场景的不同，可以选择TCP或UDP协议来进行数据的上下位机传输。</p><ol><li><strong>当精确性和完整性是首要条件时，选择TCP：</strong>如果信号数据的完整性和顺序对分析和处理至关重要，那么TCP是更好的选择。例如，在需要准确重建生物信号图像或进行深度数据分析的场景中，TCP的可靠性能够保证接收到的数据无误。 </li><li><strong>当实时性更为关键时，选择UDP：</strong>对于实时监控或者即时反馈系统，UDP由于其低延迟特性成为更优选项。在这种场景下，即便牺牲一部分数据的完整性和顺序，快速的数据传输也能更好地满足系统需求。</li></ol><h1 id="三、实际使用"><a href="#三、实际使用" class="headerlink" title="三、实际使用"></a>三、实际使用</h1><p>以实验室A型超声等多模态生物信号采集设备为例，我们可以构建一个基于TCP&#x2F;UDP的数据传输方案。假设系统需要将采集到的信号数据实时传输给上位机进行处理和显示：</p><ul><li><strong>基于TCP的方案</strong>会保证所有采集到的数据完整无误地传输到上位机，适用于对数据完整性要求极高的应用场景，比如详细的数据分析和后期处理。 </li><li><strong>基于UDP的方案</strong>则注重于数据传输的实时性，适合于实时监控和反馈，比如快速检测和预警系统。 </li><li>但是使用TCP的方案，会对下位机存在一定的压力，主要是由于TCP在保证数据传输时，可能会影响下位机信号采集的实时性，从而影响数据源。</li><li>最后我们采用UDP的方式，通过实时传输数据并添加数据标签，并在最终数据传输后重新校验数据！</li></ul><h1 id="四、技术细节和优化建议"><a href="#四、技术细节和优化建议" class="headerlink" title="四、技术细节和优化建议"></a>四、技术细节和优化建议</h1><p>无论选择TCP还是UDP，都需要考虑数据包的大小、传输速率、网络条件等因素，合理配置以达到最佳的传输效果。例如，可以通过调整TCP的窗口大小或使用UDP分片来优化性能。<br>此外，了解到新的技术如<strong>QUIC（</strong>一种基于UDP的多路复用传输协议）可以进一步提高通信的效率和可靠性，感觉值得以后进一步尝试。</p><h1 id="五、参考和进一步阅读"><a href="#五、参考和进一步阅读" class="headerlink" title="五、参考和进一步阅读"></a>五、参考和进一步阅读</h1><ul><li><a href="https://tools.ietf.org/html/rfc793">RFC 793 - TCP协议官方文档</a></li><li><a href="https://tools.ietf.org/html/rfc768">RFC 768 - UDP协议官方文档</a></li><li><a href="https://www.chromium.org/quic">QUIC协议概述</a></li></ul><h1 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h1><p>在多模态生物信号采集设备的数据传输方案中，合理选择和配置TCP&#x2F;UDP协议是保证数据传输效率和质量的关键。理解每种协议的特点和应用场景，可以帮助我们设计出更适合具体需求的通信方案。<br>希望能够为你提供实验室设备数据传输方面的一些启发和帮助。对于进一步的技术细节和应用实例，建议深入研究相关的官方文档和最新的技术文章。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于STM32H7的TCM</title>
    <link href="/2023/05/07/%E5%85%B3%E4%BA%8ESTM32H7%E7%9A%84TCM/"/>
    <url>/2023/05/07/%E5%85%B3%E4%BA%8ESTM32H7%E7%9A%84TCM/</url>
    
    <content type="html"><![CDATA[<p>最近在进行电刺激和肌电反馈设备研制时，打算使用一下STM32的H7系列，之前用F7,F4多一些，想看看H7有什么高级一点的功能！今天先简单的说一下STM32的TCM吧~</p><blockquote><p>为什么选择H7呢，因为之前F7太贵了，芯片缺货导致的F7涨价，H7性能更强，还更便宜，何乐而不为呢~</p></blockquote><p>在STM32H7系列中，TCM（Tightly-Coupled Memory，<strong>紧密耦合内存</strong>）是一种高速内存，分为ITCM和DTCM。ITCM主要用于存储指令，而DTCM用于存储数据，它们的特点是与内核速度相同，这意味着它们的访问速度比片上其他RAM更快，不会产生额外的等待周期。从紧密耦合内存这个名字，就可以看出来，这是一个相比于传统F7,F4系列的RAM更靠近CPU的内存了。<br>H7相比于F7系列，主频快了不少，我们使用的H723都达到了550MHz了，而F767才216MHz左右。针对于更快的H7系列，DTCM就能更好的加速了，毕竟支持高达400MHz的速度！搞起来！</p><h1 id="STM32-H7系列微控制器概述"><a href="#STM32-H7系列微控制器概述" class="headerlink" title="STM32 H7系列微控制器概述"></a>STM32 H7系列微控制器概述</h1><p>STM32 H7系列微控制器是STMicroelectronics推出的高端微控制器产品线，基于ARM Cortex-M7核心，运行频率高达600 MHz的处理速度和丰富的外设接口。STM32 H7的内存架构设计考虑了不同应用场景的需求，包括紧密耦合的TCM和DTCM DRAM，以及更通用的AXI SRAM和SRAM区域。这些内存区域的设计旨在提供不同级别的性能和灵活性，以满足从实时数据处理到复杂控制任务的各种需求。<br>下面是H7的一个框架图，可以看到，CPU旁边多了个ITCM，DTCM区域<br><img src="https://cdn.nlark.com/yuque/0/2024/png/22498321/1711158489059-37d8faab-7cc5-4840-8622-fb3960879d52.png" alt="image.png"></p><h1 id="TCM（Thread-Local-Cache-Memory）简介"><a href="#TCM（Thread-Local-Cache-Memory）简介" class="headerlink" title="TCM（Thread-Local Cache Memory）简介"></a>TCM（Thread-Local Cache Memory）简介</h1><p>TCM是直接与CPU核心耦合的内存区域，它包括两部分：<strong>ITCM和DTCM</strong>。ITCM用于存储指令，而DTCM用于存储数据。这种设计使得CPU能够以与核心速度相同的高速率直接访问这些内存区域，从而显著减少了指令和数据的访问延迟。</p><h2 id="ITCM（Instruction-TCM）"><a href="#ITCM（Instruction-TCM）" class="headerlink" title="ITCM（Instruction TCM）"></a>ITCM（Instruction TCM）</h2><p>ITCM是用于存储程序代码的内存区域。在STM32 H7中，ITCM的大小为64KB，地址范围从0x0000 0000开始。由于ITCM的高速访问特性，它特别适合存放关键的中断服务例程、实时任务或任何对执行速度有严格要求的代码段。</p><h2 id="DTCM（Data-TCM）"><a href="#DTCM（Data-TCM）" class="headerlink" title="DTCM（Data TCM）"></a>DTCM（Data TCM）</h2><p>DTCM是用于存储数据的内存区域，大小为128KB，地址范围从0x2000 0000开始。DTCM的设计允许CPU以与处理指令相同的速度访问数据，这对于需要快速读写操作的应用场景至关重要，如高速数据采集、信号处理等。</p><h2 id="DTCM（Data-TCM）DRAM简介"><a href="#DTCM（Data-TCM）DRAM简介" class="headerlink" title="DTCM（Data TCM）DRAM简介"></a>DTCM（Data TCM）DRAM简介</h2><p>DTCM DRAM是STM32 H7中专门用于数据存取的内存区域，它与DTCM紧密相关，但具有更大的存储容量。DTCM DRAM的设计旨在提供高带宽的数据访问，以支持数据密集型的应用。</p><h2 id="如何在STM32-H7上配置TCM和DTCM-DRAM"><a href="#如何在STM32-H7上配置TCM和DTCM-DRAM" class="headerlink" title="如何在STM32 H7上配置TCM和DTCM DRAM"></a>如何在STM32 H7上配置TCM和DTCM DRAM</h2><p>配置STM32 H7的TCM和DTCM DRAM需要对内存映射和系统时钟进行适当的设置。下面简单说一下一些配置步骤：</p><ol><li><strong>配置内存映射</strong>：在STM32CubeMX或类似的配置工具中，将代码和数据映射到相应的TCM和DTCM区域。涉及到设置内存区域的起始地址和大小，以及选择正确的访问权限和缓存策略。</li><li><strong>配置变量</strong>：在编写代码时，利用特定的编译器属性或指令将关键代码段和数据放置在TCM和DTCM区域。例如，使用GCC编译器时，可以通过__attribute__((section(“.itcm”)))将函数或数据放置在ITCM中。<blockquote><p>如果应用中使用了DMA（直接内存访问），需要确保DMA控制器能够访问TCM和DTCM区域。STM32 H7的DMA控制器支持多种内存区域，但需要注意的是，DTCM和ITCM好像只支持MDMA。（不太确定，好像DMA1，DMA2和BDMA都不支持）</p></blockquote></li></ol><h2 id="遇到的问题及解决方案"><a href="#遇到的问题及解决方案" class="headerlink" title="遇到的问题及解决方案"></a>遇到的问题及解决方案</h2><p>在配置和使用TCM和DTCM DRAM时，可能会遇到的问题包括内存映射冲突、DMA访问限制、缓存一致性问题等。</p><ul><li><strong>内存映射冲突</strong>：<ul><li>在配置TCM和DTCM DRAM时，可能会发现内存映射地址与其他内存区域或外设地址冲突。</li><li>确保TCM和DTCM区域的地址范围不会与其他内存区域重叠。</li><li>如果发生冲突，可能需要重新设计内存映射或调整代码和数据的存储位置。</li><li><strong>原因分析：</strong>可能是由于硬件设计时未充分考虑内存地址空间的分配，或者在软件开发过程中对内存地址的不当使用造成的。STM32 H7的内存空间有限，因此需要精确地规划每个功能模块的内存需求。</li></ul></li><li><strong>DMA访问限制</strong>：<ul><li>在尝试使用DMA传输数据到TCM或DTCM DRAM时，可能会发现某些DMA通道无法访问这些内存区域。</li><li>DTCM和ITCM不支持DMA1、DMA2和BDMA，仅支持MDMA。</li><li><strong>原因分析</strong>： DMA访问限制是由于TCM和DTCM DRAM的特殊设计和安全考虑。这些内存区域紧密耦合到CPU，以提供高速访问，但这种设计也意味着它们可能不支持所有类型的DMA传输，以避免潜在的冲突和性能问题。</li></ul></li></ul><p>STM32 H7系列微控制器的TCM和DTCM DRAM为嵌入式系统设计者提供了强大的性能提升工具。通过合理配置和使用这些内存区域，可以显著提高数据处理速度，从而优化整个系统的性能。在设计高性能嵌入式系统时，充分利用STM32 H7的内存管理特性是至关重要的。通过精心设计和优化，STM32 H7可以成为实现高速、高可靠性嵌入式应用的理想选择。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>STM32H7系列参考手册</li><li>STM32CubeMX配置工具</li><li>ARM Cortex-M7核心技术参考</li><li>STM32 H7数据手册</li><li>STM32 H7编程手册</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>STM32CUBEIDE分享</title>
    <link href="/2023/03/06/STM32%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/06/STM32%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>最近，开展了一下关于STM32CUBEIDE的实验室分享！</p><blockquote><p>STM32CubeIDE是一款面向STM32微控制器系列的全面开发工具，它集成了编程、调试以及性能分析的功能，为开发者提供了一个便捷的开发环境。接下来，我会分几个部分来扩展这个主题，包括STM32CubeIDE的介绍、优势、如何使用它来提高开发效率，以及一些高级特性和技巧。</p></blockquote><h1 id="STM32CubeIDE简介"><a href="#STM32CubeIDE简介" class="headerlink" title="STM32CubeIDE简介"></a>STM32CubeIDE简介</h1><p>STM32CubeIDE是基于Eclipse的集成开发环境(IDE)，专为STM32微控制器系列设计。它结合了C&#x2F;C++开发环境、单片机配置工具STM32CubeMX以及一个全面的调试和性能分析工具。通过集成这些功能，STM32CubeIDE为STM32开发者提供了一个全面的开发解决方案。</p><h2 id="STM32CubeIDE的优势"><a href="#STM32CubeIDE的优势" class="headerlink" title="STM32CubeIDE的优势"></a>STM32CubeIDE的优势</h2><ul><li><strong>一体化开发环境</strong>：STM32CubeIDE将代码开发、配置和调试功能整合在一个应用程序中，简化了开发流程。</li><li><strong>代码生成</strong>：利用STM32CubeMX的配置工具，开发者可以图形化地配置微控制器的外设和中间件，自动生成初始化代码，这极大地减少了项目启动阶段的工作量。</li><li><strong>跨平台支持</strong>：STM32CubeIDE支持Windows、Linux和macOS操作系统，方便不同平台的开发者使用。</li><li><strong>性能分析</strong>：集成的性能分析工具使得开发者可以轻松识别程序中的瓶颈，优化应用性能。</li><li><strong>广泛的芯片支持</strong>：支持所有STM32系列和型号的微控制器，包括最新的STM32H7系列。</li></ul><h1 id="如何使用STM32CubeIDE开发"><a href="#如何使用STM32CubeIDE开发" class="headerlink" title="如何使用STM32CubeIDE开发"></a>如何使用STM32CubeIDE开发</h1><ol><li><strong>项目创建与配置</strong>：利用STM32CubeIDE创建新项目时，可以选择相应的STM32微控制器型号，自动配置项目设置。使用STM32CubeMX集成工具，通过图形界面配置外设，自动生成初始化代码。</li><li><strong>代码编辑</strong>：STM32CubeIDE提供了代码高亮、自动完成、代码导航等功能。</li><li><strong>调试与性能分析</strong>：集成的调试工具支持实时调试，开发者可以逐行执行代码，检查变量值。性能分析工具帮助识别和优化代码性能问题。</li></ol><h2 id="部分高级特性和技巧"><a href="#部分高级特性和技巧" class="headerlink" title="部分高级特性和技巧"></a>部分高级特性和技巧</h2><ul><li><strong>版本控制集成</strong>：STM32CubeIDE集成了Git，方便进行版本控制和团队合作。下文介绍到了</li><li><strong>自定义外设驱动代码</strong>：虽然STM32CubeMX可以生成初始化代码，但也可以自定义外设驱动，以满足特定的性能要求或功能需求。</li><li><strong>使用FreeRTOS</strong>：对于需要实时操作系统(RTOS)的应用，STM32CubeIDE支持集成FreeRTOS，简化了多任务处理的开发工作。</li></ul><h1 id="STM32CUBEIDE汉化"><a href="#STM32CUBEIDE汉化" class="headerlink" title="STM32CUBEIDE汉化"></a>STM32CUBEIDE汉化</h1><p>安装插件<br><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1679727797597-bdf67108-44f3-4cf4-8dfd-57b4feeb7f10.png"><br>在install中选择add<br><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1679727700889-966db90a-acc9-40fb-bb83-e2ef51031b3c.png"><br>并添加如下网址：<a href="http://mirrors.ustc.edu.cn/eclipse/technology/babel/update-site/latest/">http://mirrors.ustc.edu.cn/eclipse/technology/babel/update-site/latest/</a>安装相关插件<img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1679727548707-bd4ae7cf-1a1f-43c7-ae85-10a328c035ba.png"><br>添加后会进行如下显示，从中选择最多人安装的即可<br><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1679727505870-39279df1-76f3-4f8c-a53a-3e5675ac9b47.png"><br>出现过安装时无效，同时再安装时点击next无效，这个可能是因为之前要求trust时没有trust ，可能需要从头来一遍操作</p><h1 id="STM32CUBEIDE添加-h和-c文件"><a href="#STM32CUBEIDE添加-h和-c文件" class="headerlink" title="STM32CUBEIDE添加.h和.c文件"></a>STM32CUBEIDE添加.h和.c文件</h1><p>我在个人项目下新建了文件夹PersonalCode，用于存储自己添加的文件<br>在stm32CubeIde中编译后，就会自动将文件夹添加到树中<br><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1679802233791-c3b66761-a2c4-4c57-8cbd-2c46fea75bf7.png"><br>但是此时文件内容还没有应用到整体代码中，无法直接进行函数调用，需要添加<br>在项目名右键属性中进行添加<br><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1679802346274-a3a14014-249c-4a5c-9bfb-67830581d386.png"><br>在下图中的paths and symbols中添加<br><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1679802451646-df7fb058-7b77-4a90-8f87-f12d473dada3.png"><br>如图第一栏中include中可以添加include路径，右侧add中添加路径，使用如图相对路径，可去掉项目名等，只保留在项目下的相对路径，方便后续迁移<br><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1679802501600-965c4590-2c2f-4803-85c2-9e4c781ff7f7.png"></p><h1 id="使用git进行版本管理"><a href="#使用git进行版本管理" class="headerlink" title="使用git进行版本管理"></a>使用git进行版本管理</h1><p>STM32CUBEIDE自带git，可以方便进行版本管理。当时安装时，在perferences中看到了version control，感觉可以试一下🥰<br><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1679573981762-8bb25823-202e-4e46-ba96-ecca1405f489.png"></p><ul><li>此处需要注意，stm32cubeIDE虽然集成了相关的菜单，<strong>但是默认没有安装git的相关插件</strong>，需要自行安装，大部分教程中未提及此点，需要注意。（此处可以发现stm32cubeIDE集成了插件市场，应该可以帮助完成更丰富的功能） <ul><li>安装方法：先进入插件市场，路径如图：</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1679576590834-2d90339b-93fe-4504-bb9f-c8649ccc30ec.png"><br>在市场中安装EGIT即可</p><ul><li>安装后，即可在项目右键菜单中，team栏下进入share project中配置git路径</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/22498321/1679576641483-83b8470c-7a96-4777-a7e3-62f1f88931a8.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
